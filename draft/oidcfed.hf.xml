<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN"
        "http://xml2rfc.tools.ietf.org/authoring/rfc2629.dtd">
<!--
  NOTE:  This XML file is input used to produce the authoritative copy of an
  OpenID Foundation specification.  The authoritative copy is the HTML output.
  This XML source file is not authoritative.  The statement ipr="none" is
  present only to satisfy the document compilation tool and is not indicative
  of the IPR status of this specification.  The IPR for this specification is
  described in the "Notices" section.  This is a public OpenID Foundation
  document and not a private document, as the private="..." declaration could
  be taken to indicate.
-->
<rfc category="info" docName="openid-connect-federation-1_0" ipr="none">

    <?rfc toc="yes" ?>
    <?rfc tocdepth="5" ?>
    <?rfc symrefs="yes" ?>
    <?rfc sortrefs="yes"?>
    <?rfc strict="yes" ?>
    <?rfc iprnotified="no" ?>
    <?rfc private="Draft" ?>

    <front>

        <title abbrev="OpenID Connect Federation">OpenID Connect Federation 1.0
            - draft 02
        </title>

        <author fullname="Roland Hedberg" role="editor" surname="Hedberg"
                initials="R.">
            <organization>independent</organization>
            <address>
                <email>roland@catalogix.se</email>
            </address>
        </author>

        <author fullname="Samuel Gulliksson" surname="Gulliksson"
                initials="S.">
            <organization abbrev="Schibsted">Schibsted Media Group
            </organization>
            <address>
                <email>samuel.gulliksson@gmail.com</email>
            </address>
        </author>

        <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft</organization>
            <address>
                <email>mbj@microsoft.com</email>
                <uri>http://self-issued.info/</uri>
            </address>
        </author>

        <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Ping Identity">Ping Identity</organization>
            <address>
                <email>ve7jtb@ve7jtb.com</email>
                <uri>http://www.thread-safe.com/</uri>
            </address>
        </author>

        <date day="2" month="April" year="2017"/>

        <workgroup>OpenID Connect Working Group</workgroup>

        <keyword>OIDC</keyword>

        <abstract>
            <t>The OpenID Connect standard specifies how a Relying Party (RP)
                can discover metadata about an OpenID Provider (OP), and then
                register to obtain client credentials. During discovery and
                registration
                there is no automated mechanism for the OP or the RP to verify
                the
                information exchanged during this process. All the information
                is self-asserted.
            </t>
            <t>
                In an identity federation context this is not sufficient. The
                participants of the federation must be able to trust
                information provided about other participants in the federation.
            </t>
            <t>
                This document describes how an identity federation can be built
                around a trusted third party, the federation operator.
            </t>
        </abstract>
    </front>

    <middle>
        <section anchor='Introduction' title="Introduction">
            <t>The OpenID Connect specification defines how a
                Relying Party and an OpenID Connect Provider can
                exchange information dynamically about each other. This
                information is
                necessary for future successful OIDC communication.
            </t>
            <t>One problem with using dynamic discovery and registration is that
                the correctness of the information that is exchanged can not be
                easily
                verified by the recipient as it is self-asserted.
            </t>
            <t>Another problem that has been raised is the dependency on TLS as
                the sole protection against attacks on the transferred
                information.
                These last couple of years a number of problems with openSSL,
                which
                is probably the most widely used TLS library, has been
                discovered that puts reasonable doubt into this dependency.
            </t>
            <t>
                We are extending Signed Metadata, as introduced by
                <xref target="I-D.draft-ietf-oauth-discovery">
                    OAuth 2.0 Authorization Server Metadata</xref>,
                to create what we call
                metadata statements. Metadata statements together with the
                use of a trusted third party (that verifies and enforces some
                common policy), can be used to transfer verified data and trust
                in the data between clients and servers.
            </t>
        </section>

        <section title="Requirements Language">
            <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
                NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
                "OPTIONAL" in this document are to be interpreted as described
                in<xref target="RFC2119">RFC 2119</xref>.
            </t>
        </section>
        <section title="Metadata Statement" anchor="entity_metadata">
            <t>
                A metadata statement asserts metadata values about an entity
                (client or
                server).
            </t>
            <section title="Metadata Common to All Entities">
                <t>
                    These extra metadata parameters appear in both provider
                    and client metadata statements:
                </t>
                <t>
                    <list style="hanging">
                        <t hangText="signing_keys">
                            <vspace/>
                            OPTIONAL.
                            A <xref target="RFC7517">JSON Web Key Set (JWKS)
                            </xref> representing the
                            public part of the entity's signing keys.
                            <vspace blankLines="1"/>
                            The keys that can be found here or at
                            <spanx style="verb">signing_keys_uri</spanx>
                            must not be confused with the
                            keys that an OIDC entity is using for
                            Authorization/AccessToken/RefreshToken/UserInfo
                            requests and responses. Those keys are found at
                            <spanx style="verb">jwks_uri</spanx> or in the
                            case of client registration
                            also possibly at <spanx style="verb">jwks</spanx>.
                            The signing keys are
                            used to sign metadata statements, keys found
                            at <spanx style="verb">signed_jwks_uri</spanx> and
                            can also be used by an
                            OP to sign a client registration request response.
                        </t>
                        <t hangText="signing_keys_uri">
                            <vspace/>
                            OPTIONAL.
                            Location where a JWKS representing the public part
                            of the entity's
                            signing keys can be found. SHOULD return
                            the Content-Type "application/jose" to
                            indicate that the JWKS is in the form of a
                            <xref target="RFC7515">JSON Web Signature (JWS)
                            </xref>
                            using the JWS Compact Serialization.
                        </t>
                        <t hangText="metadata_statements">
                            <vspace/>
                            OPTIONAL.
                            JSON array containing a list of metadata statements.
                        </t>
                        <t hangText="metadata_statement_uris">
                            <vspace/>
                            OPTIONAL.
                            JSON object where the names are the federation
                            identifiers and the
                            values are URLs pointing to metadata statements
                            connected to
                            each federation.
                        </t>
                        <t hangText="signed_jwks_uri">
                            <vspace/>
                            OPTIONAL.
                            This is the signed version of the
                            <spanx style="verb">jwks_uri</spanx>
                            parameter defined in <xref
                                target="OpenID.Registration">
                            OpenID Connect Dynamic Client Registration
                            1.0</xref>.
                            SHOULD return the Content-Type "application/jose" to
                            indicate that the JWKS is in the form of a JWS using
                            the JWS Compact Serialization.
                            The key used to sign the JWKS can be found in
                            <spanx style="verb">signing_keys</spanx>
                            or
                            <spanx style="verb">signing_keys_uri</spanx>.
                        </t>
                        <t hangText="federation_usage">
                            <vspace/>
                            OPTIONAL.
                            A metadata statement can be used in several
                            different
                            contexts. This parameter can be used to limit the
                            usage
                            to a specific context. The values specified in this
                            document are 'discovery', 'registration' and
                            'response'.
                            The corresponding contexts are:
                            <list style="hanging">
                                <t hangText="discovery">
                                    <vspace/>
                                    <xref target="OpenID.Discovery">
                                        Provider Information Discovery Response
                                    </xref>
                                </t>

                                <t hangText="registration">
                                    <vspace/>
                                    <xref target="OpenID.Registration">
                                        Client Registration Request
                                    </xref>
                                </t>
                                <t hangText="response">
                                    <vspace/>
                                    <xref target="OpenID.Registration">
                                        Client Registration Request response
                                    </xref>
                                </t>
                            </list>
                        </t>
                    </list>
                </t>
                <t>
                    Metadata statements and signing keys can be transferred in
                    two different ways: either by including the information in
                    the statement, or by providing a URI that points to the
                    information.
                    How metadata statements and signing keys are transferred is
                    independent of each other.
                    It is NOT allowed to divide the information (metadata
                    statements or signing keys) into two pieces and send
                    one in the statement and leave the rest to be fetched using
                    the URI.
                </t>
                <t>
                    Along the same line if both
                    <spanx style="verb">jwks_uri</spanx>
                    and
                    <spanx style="verb">signed_jwks_uri</spanx>
                    are present, which they
                    might be for backward compatibility reasons, then
                    <spanx style="verb">signed_jwks_uri</spanx>
                    SHOULD be preferred.
                </t>
                <t>
                    Metadata statements that do not contain
                    <spanx style="verb">metadata_statements</spanx>
                    or
                    <spanx style="verb">metadata_statement_uris</spanx>
                    are called
                    level 0 metadata statements.
                </t>
                <t>
                    An OP MUST sign it's JWKs and therefore publish a
                    signed_jwks_uri. Unless an RP is not able to handle secrets
                    it MUST also sign it's JWKS and publish a signed_jwks_uri.
                </t>
            </section>
            <section title="Specific Client Metadata">
                <t>
                    All parameters defined in section 2 of
                    <xref target="OpenID.Registration">
                        OpenID Connect Dynamic Client Registration 1.0
                    </xref>
                    are allowed in a metadata statement.
                </t>
                <t>
                    To that list is added:
                    <list style="hanging">
                        <t hangText="scopes">
                            <vspace/>
                            RECOMMENDED.
                            JSON array containing a list of the
                            <xref target="RFC6749">RFC6749</xref>
                            scope values that
                            this clients expects to use.
                        </t>
                        <t hangText="claims">
                            <vspace/>
                            RECOMMENDED.
                            JSON array containing a list of the Claim Names of
                            the Claims that
                            the OpenID Client wants values for.
                        </t>
                    </list>
                </t>
            </section>
            <section title="Specific Provider Metadata">
                <t>
                    All parameters defined in section 3 of
                    <xref target="OpenID.Discovery">
                        OpenID Connect Discovery 1.0
                    </xref>
                </t>
            </section>
            <section title="Compounded Metadata Statement">
                <section title="Basic components" anchor="components">
                    <t>
                        To describe Compounded Metadata Statements we need a
                        way of describing the different components in such a
                        statement.
                        These are the basic components:
                        <list style="hanging">
                            <t hangText="ms_X">
                                <vspace/>
                                Metadata Statement signing request by X without
                                signing keys and signed metadata statements.
                            </t>
                            <t hangText="SK[X]">
                                <vspace/>
                                Signing keys that belongs to X
                            </t>
                            <t hangText="X(MS)">
                                <vspace/>
                                Metadata Statement signed by X
                            </t>
                        </list>
                    </t>
                    <t anchor="Level0SMS">
                        Using these basic components we can now describe a
                        simple signed Metadata Statement as:
                        <figure>
                            <artwork>A(ms_B + SK[B])</artwork>
                        </figure>
                        B being the entity that requested a signature by A
                        of B's metadata statement and signing keys.
                    </t>
                    <t anchor="Level1SMS">
                        A more complicated compounded metadata statement would
                        then
                        be:
                        <figure>
                            <artwork>B(ms_C + SK[C) + A(ms_B + SK[B])</artwork>
                        </figure>
                        Here we have three entities involved: A which is the
                        top level entity (the federation operator) a second level
                        entity (B) representing the federation member and C
                        which could be an entity within the federation like
                        an OP or an RP owned/controlled by B.
                        If we assume that C is an RP then ms_C
                        would typically be a client registration request and
                        SK[C] would be the signing keys that the RP used to
                        sign the JWKS placed at signed_jwks_uri. The statement
                        signed by A (ms_b + SK[B]) would contain metadata
                        common to all RPs owned by the member (ms_B) and the
                        signing key (SK[B]) that the member uses to sign
                        requests from the member's RPs.
                    </t>
                    <t>
                        Note that the level N requester is the level N+1 signer.
                    </t>
                </section>
                <section title="Relationship between Metadata Statements">
                    <t>
                        The metadata for each entity in the federation is
                        described by one or more metadata statements (for
                        example, ms_0, ms_1, ..., ms_n).
                        ms_0 (the level 0 metadata statement mentioned above)
                        would be the most generic, and ms_1, ...,ms_n would in
                        turn be successively more specific.
                        ms_0 would typically contain information that belongs
                        to the organization, for instance
                        <spanx style="verb">tos_uri</spanx>,
                        <spanx style="verb">contacts</spanx>
                        and the like, while ms_n would contain information
                        that belongs to one specific entity like
                        <spanx style="verb">authorization_endpoint</spanx>
                        for an OP
                        or <spanx style="verb">redirect_uris</spanx> for a RP.
                    </t>
                </section>
                <section title="Constructing Entity Metadata" anchor="entityMD">
                    <t>
                        The metadata for a specific entity is constructed by
                        starting with the information in ms_0 and then adding
                        the information in ms_1 to ms_n using the following rule:
                    </t>
                    <t>
                        <spanx style="strong">
                            Given two metadata statements
                            ms_i and ms_j (j &gt; i, i=0,..,n-1, j=1,..,n)
                            For every claim in ms_j:
                            If the claim does not appear in ms_i add it to ms_i.
                            If the claim appears in ms_i then replace the value
                            of the claim in ms_i with the value of the claim in
                            ms_j if and only if the value in ms_j is less or
                            equal to the value in ms_i.
                        </spanx>
                        <vspace blankLines="1"/>
                        Less or equal is defined as:
                        <list style="hanging">
                            <t hangText="String">
                                <vspace/>
                                less or equal if they are the same.
                            </t>
                            <t hangText="Lists">
                                <vspace/>
                                For each value in
                                ms_j there MUST be a corresponding value in
                                ms_i that is less or equal.
                            </t>
                            <t hangText="Booleans">
                                <vspace/>
                                less or equal if they are the same.
                            </t>
                            <t hangText="Integer/Floats">
                                <vspace/>
                                Numeric comparision is used.
                            </t>
                            <t hangText="Associative array/dictionary">
                                <vspace/>
                                ms_j is less or equal to ms_i if each key in
                                ms_j exists in ms_i and ms_j[x] is less or
                                equal to ms_i[x].
                            </t>
                        </list>
                    </t>
                    <t>
                        The following is a non-normative example of
                        a set of client-specific metadata statements
                        who together form the metadata for an entity:
                        <figure>
                            <preamble>
                                ms_0
                            </preamble>
                            <artwork><![CDATA[
{
  "contacts": ["helpdesk@example.com"],
  "logo_uri": "https://example.com/logo.jpg",
  "policy_uri": "https://example.com/policy.html",
  "tos_uri": "https://example.com/tos.html"
}
            ]]></artwork>
                        </figure>
                        <figure>
                            <preamble>
                                ms_1
                            </preamble>
                            <artwork><![CDATA[
{
  "scope": "openid eduperson",
  "response_types": ["code", "code id_token"],
}
            ]]></artwork>
                        </figure>
                        <figure>
                            <preamble>
                                ms_2
                            </preamble>
                            <artwork><![CDATA[
{
  "contacts": ["rp_helpdesk@example.com"],
  "redirect_uris": ["https://example.com/rp1"],
  "response_types: ["code"]
}
            ]]></artwork>
                        </figure>
                        The metadata for the entity in question, using the rules
                        above, would then be:
                        <figure>
                            <preamble>
                                sum(ms_0...2)
                            </preamble>
                            <artwork><![CDATA[
{
  "contacts": ["helpdesk@example.com"],
  "logo_uri": "https://example.com/logo.jpg",
  "policy_uri": "https://example.com/policy.html",
  "tos_uri": "https://example.com/tos.html"
  "scope": "openid eduperson",
  "response_types": ["code"],
  "redirect_uris": ["https://example.com/rp1"],
}
            ]]></artwork>
                        </figure>

                    </t>
                </section>
            </section>
            <section title="Conceptual Model">
                <t>
                    A set of metadata statements that, like the ones above,
                    together describe an entity are brought together using the
                    <spanx style="verb">metadata_statement</spanx>
                    parameter.
                    <figure>
                        <preamble>
                            The following is a non-normative example of a
                            compounded metadata statement. Also note that the
                            the metadata_statement MUST be a signed
                            JWT. In this example, the only the parts of the
                            signed JWT payload pertinent to the example are
                            shown.
                        </preamble>
                        <artwork><![CDATA[
{
  "contacts": ["rp_helpdesk@example.com"],
  "redirect_uris": ["https://example.com/rp1"],
  "response_types: ["code"]
  "metadata_statements": [
    {
      "scope": "openid eduperson",
      "response_types": ["code", "code id_token"],
      "metadata_statements" : [
        {
          "contacts": ["helpdesk@example.com"],
          "logo_uri": "https://example.com/logo.jpg",
          "policy_uri": "https://example.com/policy.html",
          "tos_uri": "https://example.com/tos.html"
        }
      ]
    }
  ]
}
            ]]></artwork>
                    </figure>
                </t>
            </section>
            <section title="Usage">
                <t>
                    Metadata statements that are used in different contexts
                    will contain different parameters. For example, information
                    that an OP publishes about itself is not the same as what
                    an RP wants to register.
                    This together with the differences in the roles between an
                    OP and an RP, means that policies for RPs will not be the
                    same as for OPs. There is therefor a need for tagging the
                    Metadata statement such that a Metadata statement intended
                    to be used in one context can not be used in another.
                    This is the reason for the federation_usage parameter.
                </t>
            </section>
        </section>
        <section title="Trust Model">
            <t>
                The trust model is based on linking together
                signing keys, represented as <xref target="RFC7517">JWK
                Sets</xref>.
                Each signature chain is rooted in the trusted third party's
                signing keys. By verifying such signature chains, the entities
                can establish trust in the metadata.
            </t>
            <section title="Federation Operator">
                <t>
                    The Federation Operator (FO) is the trusted third
                    party. The FO MUST have a globally unique identifier.
                    It will publish a JWKS, containing the signing keys
                    that the FO will use for signing metadata submitted to it,
                    at a HTTPS URL which server certificate MUST appear in a
                    well-known
                    <xref target="RFC6962">Certificate Transparency log</xref>.
                    The key IDs of the FO's signing keys MUST be globally
                    unique.
                </t>
                <t>
                    For the following description, this is assumed to be true:
                    A federation consists of a number of members, and each
                    member has one or more representatives registered with the
                    federation.
                    These representatives are allowed to issue metadata signing
                    requests on behalf of the member to the federation. Below
                    such a representative is called a Level 0 Requester (L0Req).
                    Within each member unless all entities belonging to the
                    member are handled directly by the L0Req there may exists
                    parties that are responsible for single
                    or groups of entities. Within these parties we may have
                    further subdivisions such that we end up with Level 0, 1,
                    2, 3 or more requesters. This document makes no assumption
                    on the number of levels.
                </t>
            </section>
            <section title="The Building Block">
                <t>
                    Even though we talk about a chain of trust model, the actual
                    representation is as we have seen above a compounded
                    metadata statement.
                </t>
                <t>
                    The innermost metadata statement in the nest of metadata
                    statements is the one that the FO has signed.
                    That statement MUST NOT contain any references to other
                    metadata statements. See <xref target="Level0SMS">
                    simple signed metadata</xref> above.
                    All other metadata statements in the nest MUST contain at
                    least one reference to another metadata statement. An
                    example of this is can be seen <xref target="Level1SMS">
                    here</xref>.
                </t>
            </section>
            <section title="Constructing a Signed Metadata Statement">
                <t>
                    These are the steps that are preformed to construct a signed
                    metadata statement.
                    A metadata signing request may be about one specific entity
                    or a group of similar entities.
                </t>
                <t>
                    <list style="numbers">
                        <t>
                            The
                            <spanx style="verb">requester</spanx>
                            constructs a signing request by collecting the
                            necessary client or provider metadata as described
                            in <xref target='entity_metadata'/>.
                        </t>
                        <t>
                            If this is about the top most metadata statement
                            (ms_0) then no metadata statement will be added to
                            the metadata statement.
                            If it is a more specific metadata statement
                            (ms_1...n) then more general metadata statement/-s
                            MUST be added.
                            Dependent on setup the metadata statement can be
                            added by the requester or the signer.
                        </t>
                        <t>
                            The metadata statement is transported to the signing
                            party.
                            In the case of ms_0 this MUST be the FO. If it is
                            ms_1 it is the <spanx style="verb">LOReq</spanx>.
                            If it is ms_2 it is the L1Req and so on.
                        </t>
                        <t>
                            The signing party verifies the information in the
                            metadata statement, modifies and/or adds more
                            information according to the policy before signing
                            the statement.
                        </t>
                        <t>
                            Once signed by the signer the signed metadata is
                            sent back to
                            the <spanx style="verb">requester</spanx>.
                        </t>
                    </list>
                </t>
                <t>
                    An example of the construction of a compounded metadata
                    statement.
                    The Level 0 Requester (L0Req) sends a metadata statement
                    request to the federation operator (FO).
                    <figure>
                    <artwork><![CDATA[
L0Req -- (ms_L0Req + SK[L0Req]) --> FO
                    ]]></artwork>
                    </figure>
                    The FO verifies the information and if the federations
                    policy so demands may add extra information.
                    After signing with the FOs signing key the signed metadata
                    statement is returned to the L0Req.
                    <figure>
                    <artwork><![CDATA[
L0Req <-- FO(ms_L0Req + SK[L0Req]) --- FO
                    ]]></artwork>
                    </figure>
                    Next step that happens some time later is that the
                    L1Req sends a Metadata Statement signing requests
                    to the L0Reg.
                    <figure>
                    <artwork><![CDATA[
L1Req -- (ms_L1Req + SK[L1Req]) --> L0Req
                    ]]></artwork>
                    </figure>
                    The L0Req verifies the information in the request and adds
                    the signed L0Req metadata.
                    The L0Req may also add other information to the Metadata
                    Statement before it signs and returns it to the L1Req.
                    <figure>
                    <artwork><![CDATA[
L1Req <- L0Req(ms_L1Req + SK[L1Req] + FO(ms_L0Req+SK[L0Req])) - L0Req
                    ]]></artwork>
                    </figure>
                    This was an example using 3 levels. As said before this
                    document makes no assumption as to how many levels should
                    be used.
                </t>
            </section>
            <section title="Verifying the Metadata Statement" anchor="verify">
                <t>
                    Verifying a metadata statement you first grab the innermost
                    signed metadata statement. If this is signed by a FO you
                    have the public part of the signing keys from then you
                    can verify the signature of the metadata statement.
                    If the verification concludes that the signature was correct
                    you can now take the signing keys that was included in
                    the signed document and use those to verify the second
                    innermost signed metadata statement. And so on.
                </t>
                <t>
                    Verifying the received metadata statement involves running a
                    function similar to this:
                    <figure>
                        <artwork><![CDATA[
def verify(ms, sign_keys):
    keys = []
    pl = get_payload(ms)
    if 'metadata_statements' in pl:
        msl = []
        for statement in pl['metadata_statements']:
            _ms = verify(statement, sign_keys)
            if _ms:
                keys.append(get_keys(_ms))
                msl.append(_ms)
        pl['metadata_statements'] = msl
    elif 'metadata_statement_uris' in pl:
        msl = []
        for _iss, uri in pl['metadata_statement_uris'].items():
            statement = html_get(uri)
            _ms = verify(statement, sign_keys)
            if _ms:
                keys.append(get_keys(_ms))
                msl.append(_ms)
        pl['metadata_statements'] = msl
    else:
        return verify_signature(ms, pl['iss'], sign_keys):

    if verify_signature(ms, pl['iss'], keys):
        return pl
                       ]]></artwork>
                    </figure>
                    where the function get_payload unpacks the payload from the
                    JWS without verify the signature. The function
                    verify_signature, on the other hand, does verify the
                    signature of the JWS and if everything is correct returns
                    the JWS payload.
                </t>
            </section>
            <section title="Flattening the compounded metadata statement">
                <t>
                    Once you have a verified compounded metadata statement you
                    have to flatten it to get a useful metadata statement.
                    To do this you use the method outlined in
                    <xref target="entityMD"/>
                </t>
            </section>
        </section>
        <section title="OpenID Connect Communication">
            <figure>
                <preamble>
                    The trust between the entities is established using the
                    above described extensions in the first two steps of the
                    communication between an RP and an OP.
                    How the RP found the OP in the first place is out of scope
                    for this document.
                </preamble>
                <artwork><![CDATA[
------                             ------
|    | <--- 1) Discovery --------> |    |
| RP | <--- 2) Registration -----> | OP |
|    |                             |    |
------                             ------
        ]]>
                </artwork>
                <postamble>
                    After the discovery and registration is completed a first
                    time, those steps SHOULD only be repeated if any changes
                    occur (see notes in respective sections below).
                </postamble>
            </figure>
            <section title="Provider Discovery">
                <t>
                    The OP MUST publish its provider metadata as specified by
                    <xref target="OpenID.Discovery">OpenID Connect Discovery
                        1.0</xref>.
                    The RP makes a standard OpenID Provider Configuration
                    Request.
                    The OP responds with its provider configuration and the
                    additional metadata parameters specified above.
                </t>
                <t>
                    The OP SHOULD have the complete response signed by it's
                    superior in the signing chain and MAY have them signed
                    in advance.
                </t>
            </section>
            <section title="Client Registration" anchor="Clireg">
                <t>
                    The OP MUST support dynamic client registration
                    as described in
                    <xref target="OpenID.Registration">OpenID Connect Dynamic
                        Client
                        Registration 1.0
                    </xref>. The RP makes a Client Registration Request
                    including
                    the additional metadata specified above.
                </t>
                <t>
                    The RP SHOULD have the complete request signed by it's
                    superior in the signing chain and MAY have it signed
                    in advance.
                </t>
            </section>
            <section title="Client Registration response" anchor="cliregresp">
                <t>
                    It is unlikely that an OP can prepare a number of signed
                    Metadata
                    statements representing client registration responses in
                    advance. Still if the OP wants to have the whole response
                    signed it has two choices. Either the superior signer has
                    a service that can sign statements on-the-fly or the
                    OP signs it itself. If the later the OP needs to have
                    a blank (only containing signing_keys) metadata statement
                    signed by the superior. Once it has that it can sign the
                    response plus the signed metadata statement and construct a
                    compounded metadata statement that can be verified using the
                    method described in<xref target='verify'/>.
                </t>
            </section>
        </section>
        <section title="Belonging to Several Federations">
            <section title="Choosing federation">
                <t>
                    This draft allows any entity to belong to more then one
                    federation.
                    During the provider discovery and client registration
                    process the
                    parties has to agree on which federation to use.
                    Ultimately the OP decides.
                </t>
                <t>
                    <list style="number">
                        <t>The client asks for the provider information</t>
                        <t>The OP, using some rule, may publish one or several
                            <spanx style="verb">metadata_statements</spanx>.
                            If it publishes more than one
                            <spanx style="verb">metadata_statements</spanx>,
                            then they SHOULD be rooted in different federations.
                        </t>
                        <t>Based on what the OP published, the RP publishes
                            a number of <spanx style="verb">
                                metadata_statements</spanx>,
                            all rooted in federations that the OP belongs to.
                        </t>
                        <t>If the RP published more than one
                            <spanx style="verb">metadata_statements</spanx>,
                            then the OP should/must choose one and make that
                            known
                            in the client registration response. One way of
                            doing
                            this is described in
                            <xref target='cliregresp'/>
                        </t>
                    </list>
                </t>
            </section>
            <section title="Relying Party">
                <t>
                    An organization may be a member of more than one federation.
                    The
                    RPs it is responsible for may be members of one or more of
                    these.
                </t>
                <t>
                    This is then how to deal with this.
                    The organization registers and gets metadata signed by each
                    federation.
                    One extreme is that it will mint a new key pair for each
                    federation,
                    the other is that it will use the same key pair for all
                    federations. It does not matter which it chooses, but the
                    end
                    result MUST be that there is one signed RP registration
                    request per signing key.
                    This is then published using
                    <spanx style="verb">metadata_statement_uris</spanx>
                    or
                    <spanx style="verb">metadata_statements</spanx>.
                </t>
                <t>
                    <figure>
                        <preamble>The following is a non-normative example of an
                            absolutely minimal client registration request sent
                            to an OP:
                        </preamble>

                        <artwork><![CDATA[
{
  "redirect_uris": ["https://example.com/rp2/callback"],
  "metadata_statement_uris": {
      https://swamid.sunet.se/":
        "https://dev.example.com/rp1/idfed/swamid.jws",
      "https://www.incommon.org":
        "https://dev.example.com/rp1/idfed/incommon.jws"
  }
}
            ]]></artwork>
                    </figure>
                </t>
                <t>
                    As described above, when the OP receives a request like this
                    it will chose which federation it will work within and then
                    signal that by only returning that corresponding information
                    in the
                    <spanx style="verb">metadata_statements</spanx>
                    /
                    <spanx style="verb">metadata_statement_uris</spanx>
                    in the registration response.
                </t>
                <t>
                    <figure>
                        <preamble>The following is a non-normative example of an
                            OPs
                            response on the client registration request above:
                        </preamble>

                        <artwork><![CDATA[
{
  "client_id": "abcdefgh",
  "client_secret": "0123456789",
  "client_id_issued_at": 1462375583,
  "client_secret_expires_at": 1462379183,
  "redirect_uris": ["https://example.com/rp2/callback"],
  "metadata_statement_uris": {
    "https://swamid.sunet.se/":
      "https://dev.example.com/rp1/idfed/swamid.jws",
  }
}
            ]]></artwork>
                    </figure>

                </t>
            </section>
            <section title="OpenID Provider">
                <t>
                    An OP has the choice of whether it wants one key pair per
                    federation,
                    one key pair for everyone, or anything in between.
                    And, like the RP owner, it has to produce one signed
                    metadata
                    statement per key used.
                </t>
                <t>
                    <figure>
                        <preamble>The following is a non-normative example of an
                            OPs
                            response to a provider configuration request:
                        </preamble>
                        <artwork><![CDATA[
  {
    "issuer": "https://foo.example.org/op/fDTowvP0slEdEAcc",
    "response_types_supported": ["code", "code id_token", "token"],
    "grant_types_supported": ["authorization_code", "implicit",
        "urn:ietf:params:oauth:grant-type:jwt-bearer"],
    "subject_types_supported": ["pairwise", "public"],
    "id_token_signing_alg_values_supported": ["RS256"],
    "metadata_statement_uris": {
      "https://swamid.sunet.se/":
        "https://foo.example.org/op/idfed/swamid.jws",
      "https://www.incommon.org":
        "https://foo.example.org/op/idfed/incommon.jws"
      "https://www.switch.ch":
        "https://foo.example.org/op/idfed/switch.jws"
      "https://www.aco.net/":
        "https://foo.example.org/op/idfed/aconet.jws"
  }
            ]]></artwork>
                    </figure>
                </t>
            </section>
        </section>
        <section title="Timeouts">
            <t>There are a number of timeouts that MUST considered
                <list style="empty">
                    <t>Each signature has a timeout.</t>
                    <t>A client registration has a timeout.</t>
                </list>
            </t>
            <t>Taking this into consideration, an OP MUST NOT assign a
                lifetime to a client registration that exceeds the lifetime of
                the metadata statement signatures.
            </t>
        </section>
        <section anchor="Acknowledgements" title="Acknowledgements">
            <t>
                <list style="empty">
                    <t>Heather Flanagan</t>
                    <t>Andreas Akre Solberg</t>
                    <t>The JRA3T3 task force of GEANT4-2</t>
                    <t>Michael Schwartz</t>
                    <t>Peter Schober</t>
                </list>
            </t>
        </section>

        <!-- Possibly a 'Contributors' section ... -->

        <section anchor="IANA" title="IANA Considerations">
            <t>
                TBD
            </t>

        </section>

        <section anchor="Security" title="Security Considerations">
            <t>
                TBD
            </t>
        </section>
    </middle>

    <!--  *****BACK MATTER ***** -->

    <back>
        <!-- References split into informative and normative -->

        <!-- There are 2 ways to insert reference entries from the citation libraries:
         1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
         2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
            (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

         Both are cited textually in the same manner: by using xref elements.
         If you use the PI option, xml2rfc will, by default, try to find included files in the same
         directory as the including file. You can also define the XML_LIBRARY environment variable
         with a value containing a set of directories to search.  These can be either in the local
         filing system or remote ones accessed by http (http://domain/dir/... ).-->

        <references title="Normative References">
            <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
            <?rfc include="reference.RFC.2119"?>
            <?rfc include="reference.RFC.7515"?>
            <?rfc include="reference.RFC.7517"?>
            <?rfc include="reference.RFC.6962"?>
            <?rfc include="reference.RFC.6749"?>
            <?rfc include="reference.RFC.7591"?>
            <reference anchor="OpenID.Core"
                       target="http://openid.net/specs/openid-connect-core-1_0.html">
                <front>
                    <title>OpenID Connect Discovery 1.0</title>

                    <author fullname="Nat Sakimura" initials="N."
                            surname="Sakimura">
                        <organization abbrev="NRI">Nomura Research Institute,
                            Ltd.
                        </organization>
                    </author>

                    <author fullname="John Bradley" initials="J."
                            surname="Bradley">
                        <organization abbrev="Ping Identity">Ping Identity
                        </organization>
                    </author>

                    <author fullname="Michael B. Jones" initials="M.B."
                            surname="Jones">
                        <organization abbrev="Microsoft">Microsoft
                        </organization>
                    </author>

                    <author fullname="Breno de Medeiros" initials="B."
                            surname="de Medeiros">
                        <organization abbrev="Google">Google</organization>
                    </author>

                    <author fullname="Chuck Mortimore" initials="C."
                            surname="Mortimore">
                        <organization abbrev="Salesforce">Salesforce
                        </organization>
                    </author>

                    <date day="3" month="August" year="2015"/>
                </front>
            </reference>
            <reference anchor="OpenID.Discovery"
                       target="http://openid.net/specs/openid-connect-discovery-1_0.html">
                <front>
                    <title>OpenID Connect Discovery 1.0</title>

                    <author fullname="Nat Sakimura" initials="N."
                            surname="Sakimura">
                        <organization abbrev="NRI">Nomura Research Institute,
                            Ltd.
                        </organization>
                    </author>

                    <author fullname="John Bradley" initials="J."
                            surname="Bradley">
                        <organization abbrev="Ping Identity">Ping Identity
                        </organization>
                    </author>

                    <author fullname="Michael B. Jones" initials="M.B."
                            surname="Jones">
                        <organization abbrev="Microsoft">Microsoft
                        </organization>
                    </author>

                    <author fullname="Edmund Jay" initials="E." surname="Jay">
                        <organization abbrev="Illumila">Illumila</organization>
                    </author>

                    <date day="3" month="August" year="2015"/>
                </front>
            </reference>
            <reference anchor="OpenID.Registration"
                       target="http://openid.net/specs/openid-connect-registration-1_0.html">
                <front>
                    <title>OpenID Connect Dynamic Client Registration 1.0
                    </title>

                    <author fullname="Nat Sakimura" initials="N."
                            surname="Sakimura">
                        <organization abbrev="NRI">Nomura Research Institute,
                            Ltd.
                        </organization>
                    </author>

                    <author fullname="John Bradley" initials="J."
                            surname="Bradley">
                        <organization abbrev="Ping Identity">Ping Identity
                        </organization>
                    </author>

                    <author fullname="Michael B. Jones" initials="M.B."
                            surname="Jones">
                        <organization abbrev="Microsoft">Microsoft
                        </organization>
                    </author>

                    <date day="3" month="August" year="2015"/>
                </front>
            </reference>
            <reference anchor="I-D.draft-ietf-oauth-discovery"
                       target="https://tools.ietf.org/html/draft-ietf-oauth-discovery-04">
                <front>
                    <title>OAuth 2.0 Authorization Server Metadata
                    </title>

                    <author fullname="Nat Sakimura" initials="N."
                            surname="Sakimura">
                        <organization abbrev="NRI">Nomura Research Institute,
                            Ltd.
                        </organization>
                    </author>

                    <author fullname="John Bradley" initials="J."
                            surname="Bradley">
                        <organization abbrev="Ping Identity">Ping Identity
                        </organization>
                    </author>

                    <author fullname="Michael B. Jones" initials="M.B."
                            surname="Jones">
                        <organization abbrev="Microsoft">Microsoft
                        </organization>
                    </author>

                    <date day="3" month="August" year="2016"/>
                </front>
            </reference>
        </references>

        <!-- Here we use entities that we defined at the beginning. -->
        <section anchor="app-additional" title="Example">
            <t>
                In the following example we have these actors:
                <list style="hanging" hangIndent="15">
                    <t>Federation Operator (FO)</t>
                    <t>Federation Member representative (FMR)</t>
                    <t>Relying Party (RP), whether this is in fact an
                        OpenID Connect RP or someone acting on behalf of the
                        RP is immaterial.
                    </t>
                </list>
            </t>
            <t>
                The necessary steps for adding a Relying Party to a federation
            </t>
            <t>
                The following JWKS represents the signing key that
                the Federation Operator is using in the example below:
            </t>
            <figure>
                <artwork><![CDATA[
{
  "keys": [
    {
      "d": "DpFZnXz8fcKmOxFPfPdh3aZz44U2ZWm1Mxy6CiqHYcA80KVAY
-wrjKFV4eiSl9JENpoWXax4dpMcyJa2TdAXL9-4WqGNQAPRvdOfHcJM_uaBSG
ZwsuqAqZi_0sbNxurGgbjKV38ra-iz42fcSXHCgNdMJjCi3VixS8iASHGU82R
6mYyVeMWdX_j2RG--41PDxud4xSYCKDuR6s2qlLVXyCZqFu_Yzl5zChiNxZJ_
ggcxyL6i_hngi1oSbbVjgNKTcJNaIdOfzzcnUd5J9GP941-tylwg7NC3gRo1b
XlUx6HFx3LkYe1PdroHhQd92RPyJdPqHDfbizJ4sjXN4cNq-Q",
      "e": "AQAB",
      "kid": "uZX0-P1-TMsZRqK1SeXpdLgsLoeUNskN2W_rwBNKAtc",
      "kty": "RSA",
      "n": "rqJ_CFECPF2nBD1eXkFonJo5gGcbnCvDudm_-7f1thcQqiuY2
Xz0eKqQ2HP3Nw-wP5q2hKbNVgAQSBbMp_AgNwRFmboJKF4cFEr3ZtmvO94bM6
L15vUR2HNyX-4LaZ6S9u35jSikOVJDt1BK-72w_DKeb8O8qa2dl9k7F6QZJQT
6Nfh5rEALQLOZgwBgZAUpu2tQUh3TFpwe3J_rQtCBbI3r0W1XoM1pD3EXTm9M
I_aANRL82rh7_ZqLwGeBprD3F6ns9i5-psQ0UZ-2eVjN6J1um40U6ysu3QjFU
ZEwb0yxNVx2D9bzOPMHwo6GAzePhJ46rI8NQ0NwJdB7lNvrhw",
      "p": "y4VcmM4QZoIjsGlTE7jvkJzYAud9Hz3uexVdeTShHnS-btLyS
SP70EWdvICkHK7Z4KikNZaD3cET978LmkoG03WZcs7iEEg7hQ0N7ePMv7P1w6
X1Z2_IeWml0c4iFSMaGPJk8a65HgBZ8fYPXFtERI7e1M--oqCrsTFikP8wYQU
",
      "q": "26pTV-JNgwx3LMrqEKIoIvHwLKfjFouRZXtTnOJP9G9BZ9vhA
n1qX06M-xW02G3qGzhQEpNZKMj54APNcqkg4PH1wMJmJ-cs1T44KoNhhihoHd
6awT7PGNMo9I728CwYfkM3ZW-BsgGBzQcfdI043cV3ebXzIEWwPbqTR44p8Bs
",
      "use": "sig"
    }
  ]
}
        ]]></artwork>
            </figure>
            <section title="Relying Party joining a federation">
                <section title="Step 1 - FMR creates its signing key pair.">
                    <t>
                        The Agent for the organisation creates its signing key
                        pair.
                        <figure>
                            <artwork><![CDATA[
{
  "keys": [
    {
      "d": "RJmqe2KiVOShoTMaZBmoMLkmeZY97PW3TOgSGDgZejL6I2qdh
NlBAa3e9Nz6ggkWpxEy6IGNGetwNwS9aYA_Z6m45kaaUHXGKol_R_5s4TJryX
UppxWDuHScE_dVcfzlusm9Cq8J-U-xoaoKL36I3rakCJ_dWpsGNDpYSMenXcX
uX-gJ5-HvSTETV5Bp23izUF4BH8TSVWniD8Vk5Hv8EtWVqsqc7YmIG1zW_ctJ
hK7peymmNIVpcGpIxaT8agUOS-hcNxpN4AlYrELn2twzq8tXp5bPZNiHHNXgz
XANy5BgNFXXnZFqFiNiBn3agQxF2aiu4Ei5k5OidHTV8qeGWQ",
      "e": "AQAB",
      "kid": "z414hVxt2-nkbqgG3VFYOZGB3Miwuhe75SfWT1BQQTc",
      "kty": "RSA",
      "n": "waDXGJwu9pV3gMY7rtpq3OYSAG1HZy7qilGC3ULMxJxjhSQCJ
7M9PBC4uoF_f5178FebpKBIoT3_YzqETt9Ry_6NA_mGBq6xtjEgnmNv6ktQj8
hKI0tYheWRHMJIt2ay8IwnV-3LD0Q_Nn7E3YgGaJUBlzDgJxQQcRVGFEOcFL-
7TiKtVdPmPDGcSF7FivaGJO-MVqmDkCsZVMTZoqmKeuaqbshsDjxy9GaiImQL
e8tyzkhxEoG7qvovlGoV4AE8WroMinx0qWvglR8n041qQhrUMtoQMDCI53uLy
6ZSR0jbNNEwvDBbiqD4Hm3piAwTUrGKWYLxbeicK_7A6gF2Sw",
      "p": "3SBEMBmIGztaOpCH-C9vwr80SyXm6M1uwCoKjBOiy_-kJ03jv
acztd5CEOcCvhRLVvl3rEYSP97DR_Eju-jlKWi92tbIECGvWzgszMHLdEdjvV
vpJLlOSAfFMYsaPxa1Sw2HS7RgoAwIxD5HVcdPK-3cJ5Gi0hInbz-ufrH4ru0
",
      "q": "4CphaFI0lSGr0HNifXJBN5JkXmCZp6WX06cI4pR_DwZAHTojc
8dK1ECMHU2oP2nPn1pmAVZj4p98vO0MfTxSgNB15EmDRkic_cmS-SenUUf7Pl
3avJwpZq_qxYPqDajAgWHuuci-2zKXRlKS_ZCz1MAmx-gV0We3AnletWV52xc
",
      "use": "sig"
    }
  ]
}
]]></artwork>
                        </figure>
                    </t>
                </section>
                <section
                        title="Step 2 - The FMR submits registration data to FO">
                    <t>
                        The Federation member representative (FMR) submits
                        registration data to
                        the Federation Operator (FO).
                    </t>
                    <figure>
                        <artwork><![CDATA[
{
  "contacts": [
    "dev_admin@example.com"
  ],
  "logo_uri": "https://example.com/logo.jpg",
  "policy_uri": "https://example.com/policy.html",
  "signing_key": {
    "e": "AQAB",
    "kid": "z414hVxt2-nkbqgG3VFYOZGB3Miwuhe75SfWT1BQQTc",
    "kty": "RSA",
    "n": "waDXGJwu9pV3gMY7rtpq3OYSAG1HZy7qilGC3ULMxJxjhSQCJ7M
9PBC4uoF_f5178FebpKBIoT3_YzqETt9Ry_6NA_mGBq6xtjEgnmNv6ktQj8hK
I0tYheWRHMJIt2ay8IwnV-3LD0Q_Nn7E3YgGaJUBlzDgJxQQcRVGFEOcFL-7T
iKtVdPmPDGcSF7FivaGJO-MVqmDkCsZVMTZoqmKeuaqbshsDjxy9GaiImQLe8
tyzkhxEoG7qvovlGoV4AE8WroMinx0qWvglR8n041qQhrUMtoQMDCI53uLy6Z
SR0jbNNEwvDBbiqD4Hm3piAwTUrGKWYLxbeicK_7A6gF2Sw",
    "use": "sig"
  },
  "tos_uri": "https://example.com/tos.html"
}
           ]]></artwork>
                    </figure>
                </section>
                <section
                        title="Step 3 - FO returns a signed metadata statement"
                        anchor="Step3"
                >
                    <t>
                        The FO returns a signed metadata statement containing
                        the submitted registration data, and any applied policy
                        restrictions like response_types, signing/encryption
                        algorithms to be used and additional specific policy
                        parameters
                        like the ones specified above.
                    </t>
                    <t>
                        This is an example of a metadata statement constructed
                        by the FO before it is signed by the FO:
                    </t>
                    <figure>
                        <artwork><![CDATA[
{
  "contacts": [
    "dev_admin@example.com"
  ],
  "exp": 1462438820,
  "iat": 1462438820,
  "iss": "https://swamid.sunet.se/",
  "jti": "e920396fc2cb4ac0aaeb229674fd286a",
  "kid": "uZX0-P1-TMsZRqK1SeXpdLgsLoeUNskN2W_rwBNKAtc",
  "logo_uri": "https://example.com/logo.jpg",
  "policy_uri": "https://example.com/policy.html",
  "response_types": [
    "code",
    "code id_token",
    "token"
  ],
  "scopes": [
    "openid",
    "email",
    "phone"
  ],
  "signing_key": {
    "e": "AQAB",
    "kid": "z414hVxt2-nkbqgG3VFYOZGB3Miwuhe75SfWT1BQQTc",
    "kty": "RSA",
    "n": "waDXGJwu9pV3gMY7rtpq3OYSAG1HZy7qilGC3ULMxJxjhSQCJ7M
9PBC4uoF_f5178FebpKBIoT3_YzqETt9Ry_6NA_mGBq6xtjEgnmNv6ktQj8hK
I0tYheWRHMJIt2ay8IwnV-3LD0Q_Nn7E3YgGaJUBlzDgJxQQcRVGFEOcFL-7T
iKtVdPmPDGcSF7FivaGJO-MVqmDkCsZVMTZoqmKeuaqbshsDjxy9GaiImQLe8
tyzkhxEoG7qvovlGoV4AE8WroMinx0qWvglR8n041qQhrUMtoQMDCI53uLy6Z
SR0jbNNEwvDBbiqD4Hm3piAwTUrGKWYLxbeicK_7A6gF2Sw",
    "use": "sig"
  },
  "token_endpoint_auth_method": "private_key_jwt",
  "tos_uri": "https://example.com/tos.html"
}
            ]]></artwork>
                    </figure>
                    <t>
                        The signed version of this metadata statement, or a link
                        to it, is
                        then expected to be included in the RPs client
                        registration request
                        before being signed by the FMR's signing key.
                    </t>
                </section>
                <section title="Step 4 - The RP gets a signing key">
                    <t>
                        The RP gets a signing key. This key will be used to
                        sign the JWKS that is stored in a place pointed to by
                        signed_jwks_uri.
                        <figure>
                            <artwork><![CDATA[
{
  "keys": [
    {
      "d": "BA0bo5OR3ht2KGDeAUpZsKv-Jjo9IKpYA2x7yQhcIH3bt9T24
95pXVAHLQXXnZpjMenz7WPx94ajxIh96Bt59AYx4AwAEaBnPzK8vXLIP-A92N
P3HV7vk0p8KWsrEdDwxBaypqRXxz7V5vPGQVnOGg2eKSlP5F4-HoGpU6xDRo8
Lptcs5VNx0a9kKVqEu-YpQkc2z2uLRjl8urOu471sks38U03wRwWDElepUI28
jEjhPydVSQw-E5w3yKhHTZeh1mVdNMp7_8LDzScP1Ah5VCRLFfrmx1bOXxXZW
HpMD6vgghmaCQGmyhgEr3XNzHVlH4bfVI_2Vrxp6cxHpe3iYw",
      "e": "AQAB",
      "kid": "Tvd2gF4mcNtiYx6FyOOH83Xj_MkF-8yn_rD2Gm06RxY",
      "kty": "RSA",
      "n": "2kCKMUluhKV2INV3dS89WQ305J6JL8OJQ1cPk3GQ20Zvraa3D
CntNns1xy9gynGYUQzom7LYAqcmpu7xFGNXH0gN8JyXcCiWl02IuD6lwS6N2d
7y6xJm8-mUBiwVrAlhwWL1Bf8JRycRUQ51c6Y8yYrUf2pjeIFQBQEfUhcjNg1
3L1OUDoWJizy5QhaTe4p2uezYhKlKtSHC7T6Brs6kWJA57j8BY5Tx4p6cyWRG
sN58XXfmWg1hA1LjVIwgtSBvax7KRGUY6TXOd5Km2MvJgBOfqAYfh1z0wZRiB
dUa0RzsXavf4HGjnwPknYcSY1MwKZCzz_W0_uAiGlHFlNwLSQ",
      "p": "5279rRhB4IBf5chMgrTVwsAEKWyEsRrIVs5xLFVA5rpOKLN6q
GhLO6PU9jmsD7dYEa0IA-eTxVCCuMp09KEfyrRAn0OWpWdndu8IR_n2e4zZxB
Xbf4WuIeZwxfM5PqKi5LOnp442CthmzbsVD2OLmlgSViWSAP9SLFOBGfniTqs",
      "q": "8WtasUyu9D9StGJkgolHjofbMnxXzRqpnA-QSV71htsQD3wof
-vda8e8JkDLPPfAYuVYieCHeJYGsT9EHAG1Nyyr9OMzFeo73N1FdKGIGihWHS
uvW6sRr6FTta12ZMN7Jkm3l2rQoZALgvMtdYdDGJ-D3gwusW5nNS3-xJqMPds",
      "use": "sig"
    }
  ]
}
            ]]></artwork>
                        </figure>
                    </t>
                </section>
                <section
                        title="Step 5 - RP produces a client registration request"
                        anchor="Step5"
                >
                    <t>
                        The RP produces a client registration request, adding
                        to it information about the signing key.
                        <figure>
                            <artwork><![CDATA[
{
  "application_type": "web",
  "signed_jwks_uri": "https://example.com/rp1/jwks.jws",
  "redirect_uris": [
    "https://example.com/rp1/callback"
  ],
  "response_types": [
    "code"
  ],
  "signing_key": {
    "e": "AQAB",
    "kid": "Tvd2gF4mcNtiYx6FyOOH83Xj_MkF-8yn_rD2Gm06RxY",
    "kty": "RSA",
    "n": "2kCKMUluhKV2INV3dS89WQ305J6JL8OJQ1cPk3GQ20Zvraa3DCntN
ns1xy9gynGYUQzom7LYAqcmpu7xFGNXH0gN8JyXcCiWl02IuD6lwS6N2d7y6xJm
8-mUBiwVrAlhwWL1Bf8JRycRUQ51c6Y8yYrUf2pjeIFQBQEfUhcjNg13L1OUDoW
Jizy5QhaTe4p2uezYhKlKtSHC7T6Brs6kWJA57j8BY5Tx4p6cyWRGsN58XXfmWg
1hA1LjVIwgtSBvax7KRGUY6TXOd5Km2MvJgBOfqAYfh1z0wZRiBdUa0RzsXavf4
HGjnwPknYcSY1MwKZCzz_W0_uAiGlHFlNwLSQ",
    "use": "sig"
  }
}
            ]]></artwork>
                        </figure>
                    </t>
                </section>
                <section
                        title="Step 6 - Developer produces metadata statement for RP"
                        anchor="Step6"
                >
                    <t>
                        Developer produces metadata statement based on client
                        registration
                        request
                        <figure>
                            <artwork><![CDATA[
{
  "application_type": "web",
  "signed_jwks_uri": "https://example.com/rp1/jwks.jws",
  "redirect_uris": [
    "https://example.com/rp1/callback"
  ],
  "response_types": [
    "code"
  ],
  "signing_key": {
    "e": "AQAB",
    "kid": "Tvd2gF4mcNtiYx6FyOOH83Xj_MkF-8yn_rD2Gm06RxY",
    "kty": "RSA",
    "n": "2kCKMUluhKV2INV3dS89WQ305J6JL8OJQ1cPk3GQ20Zvraa3DCntN
ns1xy9gynGYUQzom7LYAqcmpu7xFGNXH0gN8JyXcCiWl02IuD6lwS6N2d7y6xJm
8-mUBiwVrAlhwWL1Bf8JRycRUQ51c6Y8yYrUf2pjeIFQBQEfUhcjNg13L1OUDoW
Jizy5QhaTe4p2uezYhKlKtSHC7T6Brs6kWJA57j8BY5Tx4p6cyWRGsN58XXfmWg
1hA1LjVIwgtSBvax7KRGUY6TXOd5Km2MvJgBOfqAYfh1z0wZRiBdUa0RzsXavf4
HGjnwPknYcSY1MwKZCzz_W0_uAiGlHFlNwLSQ",
    "use": "sig"
  },
  "metadata_statements": [
    "eyJraWQiOiJ1WlgwLVAxLVRNc1pScUsxU2VYcGRMZ3NMb2VVTnNrTjJXX3
J3Qk5LQXRjIiwiYWxnIjoiUlMyNTYifQ.eyJwb2xpY3lfdXJpIjogImh0dHBzOi
8vZXhhbXBsZS5jb20vcG9saWN5Lmh0bWwiLCAidG9rZW5fZW5kcG9pbnRfYXV0a
F9tZXRob2QiOiAicHJpdmF0ZV9rZXlfand0IiwgImNvbnRhY3RzIjogWyJkZXZf
YWRtaW5AZXhhbXBsZS5jb20iXSwgImxvZ29fdXJpIjogImh0dHBzOi8vZXhhbXB
sZS5jb20vbG9nby5qcGciLCAic2NvcGVzIjogWyJvcGVuaWQiLCAiZW1haWwiLC
AicGhvbmUiXSwgImlhdCI6IDE0NjI0Mzg4MjAsICJpc3MiOiAiaHR0cHM6Ly9zd
2FtaWQuc3VuZXQuc2UvIiwgImtpZCI6ICJ1WlgwLVAxLVRNc1pScUsxU2VYcGRM
Z3NMb2VVTnNrTjJXX3J3Qk5LQXRjIiwgImp0aSI6ICJlOTIwMzk2ZmMyY2I0YWM
wYWFlYjIyOTY3NGZkMjg2YSIsICJyZXNwb25zZV90eXBlcyI6IFsiY29kZSIsIC
Jjb2RlIGlkX3Rva2VuIiwgInRva2VuIl0sICJzaWduaW5nX2tleSI6IHsiZSI6I
CJBUUFCIiwgImtpZCI6ICJ6NDE0aFZ4dDItbmticWdHM1ZGWU9aR0IzTWl3dWhl
NzVTZldUMUJRUVRjIiwgImt0eSI6ICJSU0EiLCAidXNlIjogInNpZyIsICJuIjo
gIndhRFhHSnd1OXBWM2dNWTdydHBxM09ZU0FHMUhaeTdxaWxHQzNVTE14SnhqaF
NRQ0o3TTlQQkM0dW9GX2Y1MTc4RmVicEtCSW9UM19ZenFFVHQ5UnlfNk5BX21HQ
nE2eHRqRWdubU52Nmt0UWo4aEtJMHRZaGVXUkhNSkl0MmF5OEl3blYtM0xEMFFf
Tm43RTNZZ0dhSlVCbHpEZ0p4UVFjUlZHRkVPY0ZMLTdUaUt0VmRQbVBER2NTRjd
GaXZhR0pPLU1WcW1Ea0NzWlZNVFpvcW1LZXVhcWJzaHNEanh5OUdhaUltUUxlOH
R5emtoeEVvRzdxdm92bEdvVjRBRThXcm9NaW54MHFXdmdsUjhuMDQxcVFoclVNd
G9RTURDSTUzdUx5NlpTUjBqYk5ORXd2REJiaXFENEhtM3BpQXdUVXJHS1dZTHhi
ZWljS183QTZnRjJTdyJ9LCAidG9zX3VyaSI6ICJodHRwczovL2V4YW1wbGUuY29
tL3Rvcy5odG1sIiwgImV4cCI6IDE0NjI0Mzg4MjB9.ZVnHkrdGqQTP36UXwZhb9
hhcIc1hgkYNd8dGsyS-uHojrr4lYqkAyDjCr39fJnGvRnJvm_-LQDBfaKFHyGjS
Ci97uQAN72lWC-FRs-wuED0abhgSEyrpDBSG0enNvIyOP_BEbo5xx950MJrlcmO
T9s2MCI2KPKV4Rt8ZIJUdLO5kWPlfzaHkRZenCnob7sKYY4mbFosrslT0ny51yF
SbZLtvnc04dmR0Q8ccAYJkMfL4t-IIGrrKRbDB6x52_gqJ8REgbhfiN6StM6jwi
v_UydOjLXvFpsl5_5AZWWubNaIzj-4eCIpPFYjxBaOGcs0FsmD1irBDIAIQodid
YoI6aA"
  ]
}
              ]]></artwork>
                        </figure>
                        and signs it.
                        We now have the signed metadata statement aka the
                        metadata
                        that the RP will present to the OP
                    </t>
                </section>
                <section
                        title="Step 7 - RP sends a client registration request to an OP"
                        anchor="Step7"
                >
                    <t>
                        The RP sends a client registration request to the OP
                        <figure>
                            <artwork><![CDATA[
{
  "redirect_uris": [
    "https://example.com/rp1/callback"
  ],
  "metadata_statement_uris": {
    "https://swamid.sunet.se/":
      "https://dev.example.com/rp1/idfed/swamid.jws",
  }
}
              ]]></artwork>
                        </figure>
                    </t>
                </section>
                <section title="Step 8 - OP handles metadata statement">
                    <t>
                        The OP fetches the metadata statement from the URI
                        'https://dev.example.com/rp1/idfed/swamid.jws' and then
                        goes about unpacking the metadata. At this point in
                        time the OP doesn't have the necessary key to verify
                        all the signatures of the metadata.
                        Therefor it has to unpack the JWT without verifying the
                        signatures. It will then get a JSON document looking
                        like whats listed in <xref target="Step6"/>.
                        From this document
                        it can extract the metadata statement which should be
                        signed by a key belonging to the FO.
                        The OP should have the fetched the public version of
                        that key from the FO at some time prior to this.
                        It can now verify the signature of the metadata
                        statement and unpack the JWT. The JSON document it then
                        gets is the one listed in <xref target="Step3"/>.
                        The signing key specified in that document can now
                        be extracted and used to verify the signature of the
                        next part of the metadata.
                    </t>
                    <t>
                        What's remaining now for the OP is to put all the pieces
                        of the client registration request together. It will
                        have one piece from the level 0 request augmented with
                        the federation policy and then another piece from the RP.
                    </t>
                </section>
            </section>
        </section>
        <section anchor="Notices" title="Notices">
            <t>Copyright (c) 2016 The OpenID Foundation.</t>
            <t>
                The OpenID Foundation (OIDF) grants to any Contributor,
                developer,
                implementer, or other interested party a non-exclusive, royalty
                free,
                worldwide copyright license to reproduce, prepare derivative
                works from,
                distribute, perform and display, this Implementers Draft or
                Final Specification solely for the purposes of (i) developing
                specifications, and (ii) implementing Implementers Drafts and
                Final Specifications based on such documents, provided that
                attribution
                be made to the OIDF as the source of the material, but that such
                attribution
                does not indicate an endorsement by the OIDF.
            </t>
            <t>
                The technology described in this specification was
                made available from contributions from various sources,
                including members of the OpenID Foundation and others.
                Although the OpenID Foundation has taken steps to help ensure
                that the technology is available for distribution, it takes
                no position regarding the validity or scope of any intellectual
                property or other rights that might be claimed to pertain to
                the implementation or use of the technology described in
                this specification or the extent to which any license under
                such rights might or might not be available; neither does it
                represent that it has made any independent effort to identify
                any such rights. The OpenID Foundation and the contributors
                to this specification make no (and hereby expressly disclaim
                any)
                warranties (express, implied, or otherwise), including implied
                warranties of merchantability, non-infringement, fitness for
                a particular purpose, or title, related to this specification,
                and the entire risk as to implementing this specification is
                assumed by the implementer. The OpenID Intellectual
                Property Rights policy requires contributors to offer
                a patent promise not to assert certain patent claims against
                other contributors and against implementers. The OpenID
                Foundation invites
                any interested party to bring to its attention any copyrights,
                patents, patent applications, or other proprietary rights
                that may cover technology that may be required to practice
                this specification.
            </t>
        </section>

        <section anchor="History" title="Document History">
            <t>[[ To be removed from the approved specification ]]</t>
            <t>
                -02
                <list style="symbols">
                    <t>Added federation_usage parameter</t>
                    <t>Symbolic representation of signed metadata statements</t>
                </list>
            </t>
            <t>
                -01
                <list style="symbols">
                    <t>Generalizing the specification</t>
                </list>
            </t>
            <t>
                -00
                <list style="symbols">
                    <t>
                        Created openid-connect-federation-1_0-00 from
                        draft-hedberg-oidc-fed-01.
                    </t>
                </list>
            </t>

        </section>

    </back>
</rfc>
